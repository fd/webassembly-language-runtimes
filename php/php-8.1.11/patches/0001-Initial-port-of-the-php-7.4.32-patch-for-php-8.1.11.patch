From 40323e33477a91a82d7259dbd988e398872f7c9a Mon Sep 17 00:00:00 2001
From: Asen Alexandrov <alexandrov@vmware.com>
Date: Tue, 8 Nov 2022 16:07:48 +0200
Subject: [PATCH] Initial port of the php 7.4.32 patch for php 8.1.11


  19.8% Zend/
  16.0% ext/posix/
  24.1% ext/standard/
  14.4% main/streams/
  17.2% main/
   5.5% sapi/cgi/
diff --git a/Zend/zend.c b/Zend/zend.c
index be7fa210ff..6b1346abcc 100644
--- a/Zend/zend.c
+++ b/Zend/zend.c
@@ -785,7 +785,9 @@ static void executor_globals_ctor(zend_executor_globals *executor_globals) /* {{
 #endif
 	executor_globals->saved_fpu_cw_ptr = NULL;
 	executor_globals->active = 0;
+#ifndef WASM_WASI
 	executor_globals->bailout = NULL;
+#endif // WASM_WASI
 	executor_globals->error_handling  = EH_NORMAL;
 	executor_globals->exception_class = NULL;
 	executor_globals->exception = NULL;
@@ -1178,6 +1180,7 @@ ZEND_COLD void zenderror(const char *error) /* {{{ */
 ZEND_API ZEND_COLD ZEND_NORETURN void _zend_bailout(const char *filename, uint32_t lineno) /* {{{ */
 {
 
+#ifndef WASM_WASI
 	if (!EG(bailout)) {
 		zend_output_debug_string(1, "%s(%d) : Bailed out without a bailout address!", filename, lineno);
 		exit(-1);
@@ -1188,6 +1191,7 @@ ZEND_API ZEND_COLD ZEND_NORETURN void _zend_bailout(const char *filename, uint32
 	CG(in_compilation) = 0;
 	EG(current_execute_data) = NULL;
 	LONGJMP(*EG(bailout), FAILURE);
+#endif // WASM_WASI
 }
 /* }}} */
 
diff --git a/Zend/zend.h b/Zend/zend.h
index ba80a804ed..12860f99c7 100644
--- a/Zend/zend.h
+++ b/Zend/zend.h
@@ -251,6 +251,7 @@ typedef size_t (*zend_write_func_t)(const char *str, size_t str_length);
 
 #define zend_bailout()		_zend_bailout(__FILE__, __LINE__)
 
+#ifndef WASM_WASI
 #define zend_try												\
 	{															\
 		JMP_BUF *__orig_bailout = EG(bailout);					\
@@ -267,6 +268,19 @@ typedef size_t (*zend_write_func_t)(const char *str, size_t str_length);
 	}
 #define zend_first_try		EG(bailout)=NULL;	zend_try
 
+#else // WASM_WASI
+#define zend_try												\
+	{															\
+		if (1) {
+#define zend_catch												\
+		} else {
+#define zend_end_try()											\
+		}														\
+	}
+#define zend_first_try		zend_try
+#endif // WASM_WASI
+
+
 BEGIN_EXTERN_C()
 void zend_startup(zend_utility_functions *utility_functions);
 void zend_shutdown(void);
diff --git a/Zend/zend_alloc.c b/Zend/zend_alloc.c
index dfdc4e2bb4..b224d5cc78 100644
--- a/Zend/zend_alloc.c
+++ b/Zend/zend_alloc.c
@@ -79,7 +79,7 @@
 #include <fcntl.h>
 #include <errno.h>
 
-#ifndef _WIN32
+#if !defined(_WIN32) && HAVE_MMAP
 # include <sys/mman.h>
 # ifndef MAP_ANON
 #  ifdef MAP_ANONYMOUS
@@ -421,6 +421,8 @@ static void *zend_mm_mmap_fixed(void *addr, size_t size)
 {
 #ifdef _WIN32
 	return VirtualAlloc(addr, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
+#elif ! HAVE_MMAP
+	return NULL;
 #else
 	int flags = MAP_PRIVATE | MAP_ANON;
 #if defined(MAP_EXCL)
@@ -459,6 +461,10 @@ static void *zend_mm_mmap(size_t size)
 		return NULL;
 	}
 	return ptr;
+#elif ! HAVE_MMAP
+	void* ptr = malloc(size);
+	memset(ptr, 0, size);
+	return ptr;
 #else
 	void *ptr;
 
@@ -491,6 +497,8 @@ static void zend_mm_munmap(void *addr, size_t size)
 		stderr_last_error("VirtualFree() failed");
 #endif
 	}
+#elif ! HAVE_MMAP
+	free(addr);
 #else
 	if (munmap(addr, size) != 0) {
 #if ZEND_MM_ERROR
@@ -664,6 +672,11 @@ static zend_always_inline int zend_mm_bitset_is_free_range(zend_mm_bitset *bitse
 
 static void *zend_mm_chunk_alloc_int(size_t size, size_t alignment)
 {
+#if ! HAVE_MMAP
+	void* ptr = aligned_alloc(alignment, size);
+	memset(ptr, 0, size);
+	return ptr;
+#else
 	void *ptr = zend_mm_mmap(size);
 
 	if (ptr == NULL) {
@@ -710,6 +723,7 @@ static void *zend_mm_chunk_alloc_int(size_t size, size_t alignment)
 #endif
 		return ptr;
 	}
+#endif
 }
 
 static void *zend_mm_chunk_alloc(zend_mm_heap *heap, size_t size, size_t alignment)
@@ -2860,7 +2874,7 @@ ZEND_API void start_memory_manager(void)
 #else
 	alloc_globals_ctor(&alloc_globals);
 #endif
-#ifndef _WIN32
+#if !defined(_WIN32) && HAVE_MMAP
 #  if defined(_SC_PAGESIZE)
 	REAL_PAGE_SIZE = sysconf(_SC_PAGESIZE);
 #  elif defined(_SC_PAGE_SIZE)
diff --git a/Zend/zend_fibers.c b/Zend/zend_fibers.c
index 1fec85528f..5f692bf128 100644
--- a/Zend/zend_fibers.c
+++ b/Zend/zend_fibers.c
@@ -36,7 +36,7 @@
 # include <ucontext.h>
 #endif
 
-#ifndef ZEND_WIN32
+#if !defined(ZEND_WIN32) && HAVE_MMAP
 # include <unistd.h>
 # include <sys/mman.h>
 # include <limits.h>
@@ -91,7 +91,9 @@ typedef struct _zend_fiber_vm_state {
 	zend_execute_data *current_execute_data;
 	int error_reporting;
 	uint32_t jit_trace_num;
+#ifndef WASM_WASI
 	JMP_BUF *bailout;
+#endif // WASM_WASI
 	zend_fiber *active_fiber;
 } zend_fiber_vm_state;
 
@@ -104,7 +106,9 @@ static zend_always_inline void zend_fiber_capture_vm_state(zend_fiber_vm_state *
 	state->current_execute_data = EG(current_execute_data);
 	state->error_reporting = EG(error_reporting);
 	state->jit_trace_num = EG(jit_trace_num);
+#ifndef WASM_WASI
 	state->bailout = EG(bailout);
+#endif // WASM_WASI
 	state->active_fiber = EG(active_fiber);
 }
 
@@ -117,7 +121,9 @@ static zend_always_inline void zend_fiber_restore_vm_state(zend_fiber_vm_state *
 	EG(current_execute_data) = state->current_execute_data;
 	EG(error_reporting) = state->error_reporting;
 	EG(jit_trace_num) = state->jit_trace_num;
+#ifndef WASM_WASI
 	EG(bailout) = state->bailout;
+#endif // WASM_WASI
 	EG(active_fiber) = state->active_fiber;
 }
 
@@ -203,6 +209,8 @@ static zend_fiber_stack *zend_fiber_stack_allocate(size_t size)
 		return NULL;
 	}
 # endif
+#elif defined(WASM_WASI)
+	pointer = malloc(alloc_size);
 #else
 	pointer = mmap(NULL, alloc_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);
 
@@ -250,6 +258,8 @@ static void zend_fiber_stack_free(zend_fiber_stack *stack)
 
 #ifdef ZEND_WIN32
 	VirtualFree(pointer, 0, MEM_RELEASE);
+#elif defined(WASM_WASI)
+	free(pointer);
 #else
 	munmap(pointer, stack->size + ZEND_FIBER_GUARD_PAGES * page_size);
 #endif
diff --git a/Zend/zend_globals.h b/Zend/zend_globals.h
index 1726dee9ac..091aa91107 100644
--- a/Zend/zend_globals.h
+++ b/Zend/zend_globals.h
@@ -21,7 +21,9 @@
 #define ZEND_GLOBALS_H
 
 
+#ifndef WASM_WASI
 #include <setjmp.h>
+#endif
 
 #include "zend_globals_macros.h"
 
@@ -156,7 +158,9 @@ struct _zend_executor_globals {
 
 	HashTable included_files;	/* files already included */
 
+#ifndef WASM_WASI
 	JMP_BUF *bailout;
+#endif
 
 	int error_reporting;
 	int exit_status;
diff --git a/Zend/zend_types.h b/Zend/zend_types.h
index 3d42d481a6..0ff33b0300 100644
--- a/Zend/zend_types.h
+++ b/Zend/zend_types.h
@@ -1427,5 +1427,15 @@ static zend_always_inline uint32_t zval_delref_p(zval* pz) {
 #define ZVAL_COPY_OR_DUP_PROP(z, v) \
 	do { ZVAL_COPY_OR_DUP(z, v); Z_PROP_FLAG_P(z) = Z_PROP_FLAG_P(v); } while (0)
 
+#ifdef WASM_WASI
+#define	LOG_EMERG	0	/* system is unusable */
+#define	LOG_ALERT	1	/* action must be taken immediately */
+#define	LOG_CRIT	2	/* critical conditions */
+#define	LOG_ERR		3	/* error conditions */
+#define	LOG_WARNING	4	/* warning conditions */
+#define	LOG_NOTICE	5	/* normal but significant condition */
+#define	LOG_INFO	6	/* informational */
+#define	LOG_DEBUG	7	/* debug-level messages */
+#endif // WASM_WASI
 
 #endif /* ZEND_TYPES_H */
diff --git a/Zend/zend_virtual_cwd.c b/Zend/zend_virtual_cwd.c
index d8a9046d04..94964aa394 100644
--- a/Zend/zend_virtual_cwd.c
+++ b/Zend/zend_virtual_cwd.c
@@ -1393,6 +1393,8 @@ CWD_API int virtual_chmod(const char *filename, mode_t mode) /* {{{ */
 		}
 		ret = php_win32_ioutil_chmod(new_state.cwd, mode);
 	}
+#elif defined WASM_WASI
+	ret = 0;
 #else
 	ret = chmod(new_state.cwd, mode);
 #endif
@@ -1421,7 +1423,11 @@ CWD_API int virtual_chown(const char *filename, uid_t owner, gid_t group, int li
 		ret = -1;
 #endif
 	} else {
+#ifndef WASM_WASI
 		ret = chown(new_state.cwd, owner, group);
+#else
+		ret = 0;
+#endif // WASM_WASI
 	}
 
 	CWD_STATE_FREE_ERR(&new_state);
@@ -1699,8 +1705,11 @@ CWD_API FILE *virtual_popen(const char *command, const char *type) /* {{{ */
 	*ptr++ = ' ';
 
 	memcpy(ptr, command, command_length+1);
+#ifndef WASM_WASI
 	retval = popen(command_line, type);
-
+#else
+	retval = 0;
+#endif // WASM_WASI
 	efree(command_line);
 	return retval;
 }
diff --git a/ext/fileinfo/libmagic/compress.c b/ext/fileinfo/libmagic/compress.c
index 85d0b2938e..0129c20341 100644
--- a/ext/fileinfo/libmagic/compress.c
+++ b/ext/fileinfo/libmagic/compress.c
@@ -453,7 +453,7 @@ file_pipe2file(struct magic_set *ms, int fd, const void *startbuf,
 	int tfd;
 
 	(void)strlcpy(buf, "/tmp/file.XXXXXX", sizeof buf);
-#ifndef HAVE_MKSTEMP
+#if !defined(HAVE_MKSTEMP) && !defined(WASM_WASI)
 	{
 		char *ptr = mktemp(buf);
 		tfd = open(ptr, O_RDWR|O_TRUNC|O_EXCL|O_CREAT, 0600);
diff --git a/ext/fileinfo/libmagic/fsmagic.c b/ext/fileinfo/libmagic/fsmagic.c
index a1b18d479f..ff43d7bebc 100644
--- a/ext/fileinfo/libmagic/fsmagic.c
+++ b/ext/fileinfo/libmagic/fsmagic.c
@@ -167,6 +167,7 @@ file_fsmagic(struct magic_set *ms, const char *fn, zend_stat_t *sb)
 # endif
 #endif
 
+#ifndef WASM_WASI
 #ifdef	S_IFIFO
 	case S_IFIFO:
 		if((ms->flags & MAGIC_DEVICES) != 0)
@@ -179,6 +180,7 @@ file_fsmagic(struct magic_set *ms, const char *fn, zend_stat_t *sb)
 			return -1;
 		break;
 #endif
+#endif // WASM_WASI
 #ifdef	S_IFDOOR
 	case S_IFDOOR:
 		if (mime) {
diff --git a/ext/pdo_sqlite/sqlite_statement.c b/ext/pdo_sqlite/sqlite_statement.c
index 90de059a3b..2e83f01af6 100644
--- a/ext/pdo_sqlite/sqlite_statement.c
+++ b/ext/pdo_sqlite/sqlite_statement.c
@@ -32,7 +32,9 @@ static int pdo_sqlite_stmt_dtor(pdo_stmt_t *stmt)
 	pdo_sqlite_stmt *S = (pdo_sqlite_stmt*)stmt->driver_data;
 
 	if (S->stmt) {
+#ifndef WASM_WASI
 		sqlite3_finalize(S->stmt);
+#endif
 		S->stmt = NULL;
 	}
 	efree(S);
diff --git a/ext/posix/posix.c b/ext/posix/posix.c
index e6655f0d95..9b5e6431af 100644
--- a/ext/posix/posix.c
+++ b/ext/posix/posix.c
@@ -38,8 +38,10 @@
 #include <signal.h>
 #include <sys/times.h>
 #include <errno.h>
+#ifndef WASM_WASI
 #include <grp.h>
 #include <pwd.h>
+#endif // WASM_WASI
 #ifdef HAVE_SYS_MKDEV_H
 # include <sys/mkdev.h>
 #endif
@@ -196,6 +198,7 @@ ZEND_GET_MODULE(posix)
 
 PHP_FUNCTION(posix_kill)
 {
+#ifndef WASM_WASI
 	zend_long pid, sig;
 
 	ZEND_PARSE_PARAMETERS_START(2, 2)
@@ -207,7 +210,7 @@ PHP_FUNCTION(posix_kill)
 		POSIX_G(last_error) = errno;
 		RETURN_FALSE;
 	}
-
+#endif // WASM_WASI
 	RETURN_TRUE;
 }
 /* }}} */
@@ -215,56 +218,88 @@ PHP_FUNCTION(posix_kill)
 /* {{{ Get the current process id (POSIX.1, 4.1.1) */
 PHP_FUNCTION(posix_getpid)
 {
+#ifndef WASM_WASI
 	PHP_POSIX_RETURN_LONG_FUNC(getpid);
+#else
+	RETURN_LONG(0);
+#endif // WASM_WASI
 }
 /* }}} */
 
 /* {{{ Get the parent process id (POSIX.1, 4.1.1) */
 PHP_FUNCTION(posix_getppid)
 {
+#ifndef WASM_WASI
 	PHP_POSIX_RETURN_LONG_FUNC(getppid);
+#else
+	RETURN_LONG(0);
+#endif // WASM_WASI
 }
 /* }}} */
 
 /* {{{ Get the current user id (POSIX.1, 4.2.1) */
 PHP_FUNCTION(posix_getuid)
 {
+#ifndef WASM_WASI
 	PHP_POSIX_RETURN_LONG_FUNC(getuid);
+#else
+	RETURN_LONG(0);
+#endif // WASM_WASI
 }
 /* }}} */
 
 /* {{{ Get the current group id (POSIX.1, 4.2.1) */
 PHP_FUNCTION(posix_getgid)
 {
+#ifndef WASM_WASI
 	PHP_POSIX_RETURN_LONG_FUNC(getgid);
+#else
+	RETURN_LONG(0);
+#endif // WASM_WASI
 }
 /* }}} */
 
 /* {{{ Get the current effective user id (POSIX.1, 4.2.1) */
 PHP_FUNCTION(posix_geteuid)
 {
+#ifndef WASM_WASI
 	PHP_POSIX_RETURN_LONG_FUNC(geteuid);
+#else
+	RETURN_LONG(0);
+#endif // WASM_WASI
 }
 /* }}} */
 
 /* {{{ Get the current effective group id (POSIX.1, 4.2.1) */
 PHP_FUNCTION(posix_getegid)
 {
+#ifndef WASM_WASI
 	PHP_POSIX_RETURN_LONG_FUNC(getegid);
+#else
+	RETURN_LONG(0);
+#endif // WASM_WASI
 }
 /* }}} */
 
 /* {{{ Set user id (POSIX.1, 4.2.2) */
 PHP_FUNCTION(posix_setuid)
 {
+#ifndef WASM_WASI
 	PHP_POSIX_SINGLE_ARG_FUNC(setuid);
+#else
+	RETURN_LONG(0);
+#endif // WASM_WASI
 }
 /* }}} */
 
 /* {{{ Set group id (POSIX.1, 4.2.2) */
 PHP_FUNCTION(posix_setgid)
 {
+#ifndef WASM_WASI
 	PHP_POSIX_SINGLE_ARG_FUNC(setgid);
+#else
+	RETURN_LONG(0);
+#endif // WASM_WASI
 }
 /* }}} */
 
@@ -272,7 +307,11 @@ PHP_FUNCTION(posix_setgid)
 #ifdef HAVE_SETEUID
 PHP_FUNCTION(posix_seteuid)
 {
+#ifndef WASM_WASI
 	PHP_POSIX_SINGLE_ARG_FUNC(seteuid);
+#else
+	RETURN_LONG(0);
+#endif // WASM_WASI
 }
 #endif
 /* }}} */
@@ -281,7 +320,11 @@ PHP_FUNCTION(posix_seteuid)
 #ifdef HAVE_SETEGID
 PHP_FUNCTION(posix_setegid)
 {
+#ifndef WASM_WASI
 	PHP_POSIX_SINGLE_ARG_FUNC(setegid);
+#else
+	RETURN_LONG(0);
+#endif // WASM_WASI
 }
 #endif
 /* }}} */
@@ -341,7 +384,11 @@ PHP_FUNCTION(posix_getlogin)
 /* {{{ Get current process group id (POSIX.1, 4.3.1) */
 PHP_FUNCTION(posix_getpgrp)
 {
+#ifndef WASM_WASI
 	PHP_POSIX_RETURN_LONG_FUNC(getpgrp);
+#else
+	RETURN_LONG(0);
+#endif // WASM_WASI
 }
 /* }}} */
 
@@ -349,7 +396,11 @@ PHP_FUNCTION(posix_getpgrp)
 #ifdef HAVE_SETSID
 PHP_FUNCTION(posix_setsid)
 {
+#ifndef WASM_WASI
 	PHP_POSIX_RETURN_LONG_FUNC(setsid);
+#else
+	RETURN_LONG(0);
+#endif // WASM_WASI
 }
 #endif
 /* }}} */
@@ -357,6 +408,7 @@ PHP_FUNCTION(posix_setsid)
 /* {{{ Set process group id for job control (POSIX.1, 4.3.3) */
 PHP_FUNCTION(posix_setpgid)
 {
+#ifndef WASM_WASI
 	zend_long pid, pgid;
 
 	ZEND_PARSE_PARAMETERS_START(2, 2)
@@ -368,6 +420,7 @@ PHP_FUNCTION(posix_setpgid)
 		POSIX_G(last_error) = errno;
 		RETURN_FALSE;
 	}
+#endif // WASM_WASI
 
 	RETURN_TRUE;
 }
@@ -535,6 +588,7 @@ PHP_FUNCTION(posix_ttyname)
 		default:
 			fd = zval_get_long(z_fd);
 	}
+#ifndef WASM_WASI
 #if defined(ZTS) && defined(HAVE_TTYNAME_R) && defined(_SC_TTY_NAME_MAX)
 	buflen = sysconf(_SC_TTY_NAME_MAX);
 	if (buflen < 1) {
@@ -555,7 +609,8 @@ PHP_FUNCTION(posix_ttyname)
 		RETURN_FALSE;
 	}
 #endif
-	RETURN_STRING(p);
+#endif // WASM_WASI
+	RETURN_STRING("");
 }
 /* }}} */
 
@@ -701,6 +756,7 @@ int php_posix_group_to_array(struct group *g, zval *array_group) /* {{{ */
 	zval array_members;
 	int count;
 
+#ifndef WASM_WASI
 	if (NULL == g)
 		return 0;
 
@@ -728,6 +784,9 @@ int php_posix_group_to_array(struct group *g, zval *array_group) /* {{{ */
 	zend_hash_str_update(Z_ARRVAL_P(array_group), "members", sizeof("members")-1, &array_members);
 	add_assoc_long(array_group, "gid", g->gr_gid);
 	return 1;
+#else
+	return 0;
+#endif // WASM_WASI
 }
 /* }}} */
 
@@ -785,6 +844,7 @@ PHP_FUNCTION(posix_access)
 /* {{{ Group database access (POSIX.1, 9.2.1) */
 PHP_FUNCTION(posix_getgrnam)
 {
+#ifndef WASM_WASI
 	char *name;
 	struct group *g;
 	size_t name_len;
@@ -833,12 +893,16 @@ try_again:
 #if defined(ZTS) && defined(HAVE_GETGRNAM_R) && defined(_SC_GETGR_R_SIZE_MAX)
 	efree(buf);
 #endif
+#else
+	RETURN_FALSE;
+#endif // WASM_WASI
 }
 /* }}} */
 
 /* {{{ Group database access (POSIX.1, 9.2.1) */
 PHP_FUNCTION(posix_getgrgid)
 {
+#ifndef WASM_WASI
 	zend_long gid;
 #if defined(ZTS) && defined(HAVE_GETGRGID_R) && defined(_SC_GETGR_R_SIZE_MAX)
 	int ret;
@@ -891,11 +955,15 @@ try_again:
 #if defined(ZTS) && defined(HAVE_GETGRGID_R) && defined(_SC_GETGR_R_SIZE_MAX)
 	efree(grbuf);
 #endif
+#else
+	RETURN_FALSE;
+#endif // WASM_WASI
 }
 /* }}} */
 
 int php_posix_passwd_to_array(struct passwd *pw, zval *return_value) /* {{{ */
 {
+#ifndef WASM_WASI
 	if (NULL == pw)
 		return 0;
 	if (NULL == return_value || Z_TYPE_P(return_value) != IS_ARRAY)
@@ -909,12 +977,16 @@ int php_posix_passwd_to_array(struct passwd *pw, zval *return_value) /* {{{ */
 	add_assoc_string(return_value, "dir",       pw->pw_dir);
 	add_assoc_string(return_value, "shell",     pw->pw_shell);
 	return 1;
+#else
+	return 0;
+#endif // WASM_WASI
 }
 /* }}} */
 
 /* {{{ User database access (POSIX.1, 9.2.2) */
 PHP_FUNCTION(posix_getpwnam)
 {
+#ifndef WASM_WASI
 	struct passwd *pw;
 	char *name;
 	size_t name_len;
@@ -963,12 +1035,16 @@ try_again:
 #if defined(ZTS) && defined(_SC_GETPW_R_SIZE_MAX) && defined(HAVE_GETPWNAM_R)
 	efree(buf);
 #endif
+#else
+	RETURN_FALSE;
+#endif // WASM_WASI
 }
 /* }}} */
 
 /* {{{ User database access (POSIX.1, 9.2.2) */
 PHP_FUNCTION(posix_getpwuid)
 {
+#ifndef WASM_WASI
 	zend_long uid;
 #if defined(ZTS) && defined(_SC_GETPW_R_SIZE_MAX) && defined(HAVE_GETPWUID_R)
 	struct passwd _pw;
@@ -1019,6 +1095,9 @@ try_again:
 #if defined(ZTS) && defined(_SC_GETPW_R_SIZE_MAX) && defined(HAVE_GETPWUID_R)
 	efree(pwbuf);
 #endif
+#else
+	RETURN_FALSE;
+#endif // WASM_WASI
 }
 /* }}} */
 
diff --git a/ext/session/mod_files.c b/ext/session/mod_files.c
index 1da25ba583..60d301f002 100644
--- a/ext/session/mod_files.c
+++ b/ext/session/mod_files.c
@@ -192,6 +192,7 @@ static void ps_files_open(ps_files *data, const char *key)
 #endif
 
 		if (data->fd != -1) {
+#ifndef WASM_WASI
 #ifndef PHP_WIN32
 			/* check that this session file was created by us or root – we
 			   don't want to end up accepting the sessions of another webapp
@@ -211,6 +212,7 @@ static void ps_files_open(ps_files *data, const char *key)
 			do {
 				ret = flock(data->fd, LOCK_EX);
 			} while (ret == -1 && errno == EINTR);
+#endif // WASM_WASI
 
 #ifdef F_SETFD
 # ifndef FD_CLOEXEC
diff --git a/ext/standard/basic_functions.c b/ext/standard/basic_functions.c
index 23f736d200..09e2ff676a 100755
--- a/ext/standard/basic_functions.c
+++ b/ext/standard/basic_functions.c
@@ -61,11 +61,13 @@ typedef struct yy_buffer_state *YY_BUFFER_STATE;
 #include <sys/stat.h>
 #endif
 
+#ifndef WASM_WASI
 #ifndef PHP_WIN32
 # include <netdb.h>
 #else
 #include "win32/inet.h"
 #endif
+#endif // WASM_WASI
 
 #if HAVE_ARPA_INET_H
 # include <arpa/inet.h>
@@ -520,9 +522,11 @@ PHP_RSHUTDOWN_FUNCTION(basic) /* {{{ */
 
 	BG(mt_rand_is_seeded) = 0;
 
+#ifndef WASM_WASI
 	if (BG(umask) != -1) {
 		umask(BG(umask));
 	}
+#endif // WASM_WASI
 
 	/* Check if locale was changed and change it back
 	 * to the value in startup environment */
@@ -2456,6 +2460,7 @@ PHP_FUNCTION(move_uploaded_file)
 
 	if (VCWD_RENAME(path, new_path) == 0) {
 		successful = 1;
+#ifndef WASM_WASI
 #ifndef PHP_WIN32
 		oldmask = umask(077);
 		umask(oldmask);
@@ -2466,6 +2471,7 @@ PHP_FUNCTION(move_uploaded_file)
 			php_error_docref(NULL, E_WARNING, "%s", strerror(errno));
 		}
 #endif
+#endif // WASM_WASI
 	} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR) == SUCCESS) {
 		VCWD_UNLINK(path);
 		successful = 1;
diff --git a/ext/standard/dns.c b/ext/standard/dns.c
index 6d22e644a8..902f726b05 100644
--- a/ext/standard/dns.c
+++ b/ext/standard/dns.c
@@ -34,7 +34,9 @@
 #if HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
+#ifndef WASM_WASI
 #include <netdb.h>
+#endif // WASM_WASI
 #ifdef _OSD_POSIX
 #undef STATUS
 #undef T_UNSPEC
@@ -172,6 +174,7 @@ PHP_FUNCTION(gethostbyaddr)
 /* {{{ php_gethostbyaddr */
 static zend_string *php_gethostbyaddr(char *ip)
 {
+#ifndef WASM_WASI
 #if HAVE_IPV6 && HAVE_INET_PTON
 	struct sockaddr_in sa4;
 	struct sockaddr_in6 sa6;
@@ -213,6 +216,9 @@ static zend_string *php_gethostbyaddr(char *ip)
 
 	return zend_string_init(hp->h_name, strlen(hp->h_name), 0);
 #endif
+#else
+	return NULL;
+#endif // WASM_WASI
 }
 /* }}} */
 
@@ -239,6 +245,7 @@ PHP_FUNCTION(gethostbyname)
 /* {{{ Return a list of IP addresses that a given hostname resolves to. */
 PHP_FUNCTION(gethostbynamel)
 {
+#ifndef WASM_WASI
 	char *hostname;
 	size_t hostname_len;
 	struct hostent *hp;
@@ -280,12 +287,16 @@ PHP_FUNCTION(gethostbynamel)
 		add_next_index_string(return_value, inet_ntoa(in));
 #endif
 	}
+#else
+	RETURN_FALSE;
+#endif // WASM_WASI
 }
 /* }}} */
 
 /* {{{ php_gethostbyname */
 static zend_string *php_gethostbyname(char *name)
 {
+#ifndef WASM_WASI
 	struct hostent *hp;
 	struct in_addr *h_addr_0; /* Don't call this h_addr, it's a macro! */
 	struct in_addr in;
@@ -313,6 +324,9 @@ static zend_string *php_gethostbyname(char *name)
 	address = inet_ntoa(in);
 #endif
 	return zend_string_init(address, strlen(address), 0);
+#else
+	return NULL;
+#endif // WASM_WASI
 }
 /* }}} */
 
diff --git a/ext/standard/exec.c b/ext/standard/exec.c
index 1831b8eaa5..a4df3a8a5b 100644
--- a/ext/standard/exec.c
+++ b/ext/standard/exec.c
@@ -113,6 +113,7 @@ static size_t handle_line(int type, zval *array, char *buf, size_t bufl) {
  */
 PHPAPI int php_exec(int type, const char *cmd, zval *array, zval *return_value)
 {
+#ifndef WASM_WASI
 	FILE *fp;
 	char *buf;
 	int pclose_return;
@@ -200,7 +201,10 @@ err:
 	pclose_return = -1;
 	RETVAL_FALSE;
 	goto done;
-}
+#else
+	return 0;
+#endif // WASM_WASI
+ }
 /* }}} */
 
 static void php_exec_ex(INTERNAL_FUNCTION_PARAMETERS, int mode) /* {{{ */
@@ -512,6 +516,7 @@ PHP_FUNCTION(escapeshellarg)
 /* {{{ Execute command via shell and return complete output as string */
 PHP_FUNCTION(shell_exec)
 {
+#ifndef WASM_WASI
 	FILE *in;
 	char *command;
 	size_t command_len;
@@ -547,7 +552,10 @@ PHP_FUNCTION(shell_exec)
 	if (ret && ZSTR_LEN(ret) > 0) {
 		RETVAL_STR(ret);
 	}
-}
+#else
+	RETURN_FALSE;
+#endif
+ }
 /* }}} */
 
 #ifdef HAVE_NICE
diff --git a/ext/standard/file.c b/ext/standard/file.c
index 4c31ee0eae..5abc991341 100644
--- a/ext/standard/file.c
+++ b/ext/standard/file.c
@@ -55,7 +55,9 @@
 # endif
 # include <sys/socket.h>
 # include <netinet/in.h>
-# include <netdb.h>
+# ifndef WASM_WASI
+#  include <netdb.h>
+# endif // WASM_WASI
 # if HAVE_ARPA_INET_H
 #  include <arpa/inet.h>
 # endif
@@ -923,6 +925,7 @@ PHPAPI PHP_FUNCTION(fclose)
 /* {{{ Execute a command and open either a read or a write pipe to it */
 PHP_FUNCTION(popen)
 {
+#ifndef WASM_WASI
 	char *command, *mode;
 	size_t command_len, mode_len;
 	FILE *fp;
@@ -972,6 +975,9 @@ PHP_FUNCTION(popen)
 	}
 
 	efree(posix_mode);
+#else
+	RETURN_FALSE;
+#endif // WASM_WASI
 }
 /* }}} */
 
@@ -1353,6 +1359,7 @@ PHP_FUNCTION(readfile)
 /* {{{ Return or change the umask */
 PHP_FUNCTION(umask)
 {
+#ifndef WASM_WASI
 	zend_long mask = 0;
 	bool mask_is_null = 1;
 	int oldumask;
@@ -1375,6 +1382,9 @@ PHP_FUNCTION(umask)
 	}
 
 	RETURN_LONG(oldumask);
+#else
+	RETURN_LONG(0);
+#endif // WASM_WASI
 }
 /* }}} */
 
diff --git a/ext/standard/filestat.c b/ext/standard/filestat.c
index 83fc6837c6..65b854c7cf 100644
--- a/ext/standard/filestat.c
+++ b/ext/standard/filestat.c
@@ -326,12 +326,16 @@ PHPAPI int php_get_gid_by_name(const char *name, gid_t *gid)
 		efree(grbuf);
 		*gid = gr.gr_gid;
 #else
+#ifndef WASM_WASI
 		struct group *gr = getgrnam(name);
 
 		if (!gr) {
 			return FAILURE;
 		}
 		*gid = gr->gr_gid;
+#else
+		*gid = 0;
+#endif // WASM_WASI
 #endif
 		return SUCCESS;
 }
@@ -399,6 +403,7 @@ static void php_do_chgrp(INTERNAL_FUNCTION_PARAMETERS, int do_lchgrp) /* {{{ */
 		RETURN_FALSE;
 	}
 
+#ifndef WASM_WASI
 	if (do_lchgrp) {
 #if HAVE_LCHOWN
 		ret = VCWD_LCHOWN(filename, -1, gid);
@@ -410,6 +415,7 @@ static void php_do_chgrp(INTERNAL_FUNCTION_PARAMETERS, int do_lchgrp) /* {{{ */
 		php_error_docref(NULL, E_WARNING, "%s", strerror(errno));
 		RETURN_FALSE;
 	}
+#endif // WASM_WASI
 	RETURN_TRUE;
 #endif
 }
@@ -452,12 +458,16 @@ PHPAPI uid_t php_get_uid_by_name(const char *name, uid_t *uid)
 		efree(pwbuf);
 		*uid = pw.pw_uid;
 #else
+#ifndef WASM_WASI
 		struct passwd *pw = getpwnam(name);
 
 		if (!pw) {
 			return FAILURE;
 		}
 		*uid = pw->pw_uid;
+#else
+		*uid = 0;
+#endif // WASM_WASI
 #endif
 		return SUCCESS;
 }
@@ -465,6 +475,7 @@ PHPAPI uid_t php_get_uid_by_name(const char *name, uid_t *uid)
 
 static void php_do_chown(INTERNAL_FUNCTION_PARAMETERS, int do_lchown) /* {{{ */
 {
+#ifndef WASM_WASI
 	char *filename;
 	size_t filename_len;
 	zend_string *user_str;
@@ -539,6 +550,9 @@ static void php_do_chown(INTERNAL_FUNCTION_PARAMETERS, int do_lchown) /* {{{ */
 	}
 	RETURN_TRUE;
 #endif
+#else
+	RETURN_TRUE;
+#endif // WASM_WASI
 }
 /* }}} */
 
@@ -563,6 +577,7 @@ PHP_FUNCTION(lchown)
 /* {{{ Change file mode */
 PHP_FUNCTION(chmod)
 {
+#ifndef WASM_WASI
 	char *filename;
 	size_t filename_len;
 	zend_long mode;
@@ -601,6 +616,7 @@ PHP_FUNCTION(chmod)
 		php_error_docref(NULL, E_WARNING, "%s", strerror(errno));
 		RETURN_FALSE;
 	}
+#endif // WASM_WASI
 	RETURN_TRUE;
 }
 /* }}} */
@@ -855,6 +871,7 @@ PHPAPI void php_stat(zend_string *filename, int type, zval *return_value)
 
 	stat_sb = &ssb.sb;
 
+#ifndef WASM_WASI
 	if (type >= FS_IS_W && type <= FS_IS_X) {
 		if(ssb.sb.st_uid==getuid()) {
 			rmask=S_IRUSR;
@@ -895,6 +912,7 @@ PHPAPI void php_stat(zend_string *filename, int type, zval *return_value)
 			}
 		}
 	}
+#endif // WASM_WASI
 
 	switch (type) {
 	case FS_PERMS:
@@ -919,7 +937,9 @@ PHPAPI void php_stat(zend_string *filename, int type, zval *return_value)
 			RETURN_STRING("link");
 		}
 		switch(ssb.sb.st_mode & S_IFMT) {
+#ifndef WASM_WASI
 		case S_IFIFO: RETURN_STRING("fifo");
+#endif // WASM_WASI
 		case S_IFCHR: RETURN_STRING("char");
 		case S_IFDIR: RETURN_STRING("dir");
 		case S_IFBLK: RETURN_STRING("block");
diff --git a/ext/standard/flock_compat.c b/ext/standard/flock_compat.c
index 6b4fa3dced..03f6664a1b 100644
--- a/ext/standard/flock_compat.c
+++ b/ext/standard/flock_compat.c
@@ -26,7 +26,12 @@ PHPAPI int flock(int fd, int operation)
 #endif /* !defined(HAVE_FLOCK) */
 
 PHPAPI int php_flock(int fd, int operation)
-#if HAVE_STRUCT_FLOCK /* {{{ */
+#if defined(WASM_WASI)
+{
+	errno = 0;
+	return 0;
+}
+#elif HAVE_STRUCT_FLOCK /* {{{ */
 {
 	struct flock flck;
 	int ret;
diff --git a/ext/standard/ftp_fopen_wrapper.c b/ext/standard/ftp_fopen_wrapper.c
index f20f4245bd..34b882ddd1 100644
--- a/ext/standard/ftp_fopen_wrapper.c
+++ b/ext/standard/ftp_fopen_wrapper.c
@@ -48,7 +48,9 @@
 #include <winsock2.h>
 #else
 #include <netinet/in.h>
+#ifndef WASM_WASI
 #include <netdb.h>
+#endif
 #if HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
diff --git a/ext/standard/http_fopen_wrapper.c b/ext/standard/http_fopen_wrapper.c
index 5964efd2f9..de8f54a9d9 100644
--- a/ext/standard/http_fopen_wrapper.c
+++ b/ext/standard/http_fopen_wrapper.c
@@ -51,7 +51,9 @@
 #include <winsock2.h>
 #else
 #include <netinet/in.h>
+#ifndef WASM_WASI
 #include <netdb.h>
+#endif
 #if HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
diff --git a/ext/standard/mail.c b/ext/standard/mail.c
index 003fad3ea1..ae583a01db 100644
--- a/ext/standard/mail.c
+++ b/ext/standard/mail.c
@@ -372,6 +372,7 @@ static int php_mail_detect_multiple_crlf(const char *hdr) {
 /* {{{ php_mail */
 PHPAPI int php_mail(const char *to, const char *subject, const char *message, const char *headers, const char *extra_cmd)
 {
+#ifndef WASM_WASI
 #ifdef PHP_WIN32
 	int tsm_err;
 	char *tsm_errmsg = NULL;
@@ -551,6 +552,9 @@ PHPAPI int php_mail(const char *to, const char *subject, const char *message, co
 	}
 
 	MAIL_RET(1); /* never reached */
+#else
+	return 0;
+#endif // WASM_WASI
 }
 /* }}} */
 
diff --git a/ext/standard/microtime.c b/ext/standard/microtime.c
index ca8643eb51..f39e90fdc0 100644
--- a/ext/standard/microtime.c
+++ b/ext/standard/microtime.c
@@ -126,6 +126,7 @@ PHP_FUNCTION(getrusage)
 	PHP_RUSAGE_PARA(ru_majflt);
 	PHP_RUSAGE_PARA(ru_maxrss);
 #elif !defined(_OSD_POSIX) && !defined(__HAIKU__)
+#ifndef WASM_WASI
 	PHP_RUSAGE_PARA(ru_oublock);
 	PHP_RUSAGE_PARA(ru_inblock);
 	PHP_RUSAGE_PARA(ru_msgsnd);
@@ -139,6 +140,7 @@ PHP_FUNCTION(getrusage)
 	PHP_RUSAGE_PARA(ru_nvcsw);
 	PHP_RUSAGE_PARA(ru_nivcsw);
 	PHP_RUSAGE_PARA(ru_nswap);
+#endif // WASM_WASI
 #endif /*_OSD_POSIX*/
 	PHP_RUSAGE_PARA(ru_utime.tv_usec);
 	PHP_RUSAGE_PARA(ru_utime.tv_sec);
diff --git a/ext/standard/net.c b/ext/standard/net.c
index c549bfbc5b..32db22caa1 100644
--- a/ext/standard/net.c
+++ b/ext/standard/net.c
@@ -43,7 +43,7 @@
 # include <ws2ipdef.h>
 # include <Ws2tcpip.h>
 # include <iphlpapi.h>
-#else
+#elif ! defined(WASM_WASI)
 # include <netdb.h>
 #endif
 
@@ -86,6 +86,7 @@ PHPAPI zend_string* php_inet_ntop(const struct sockaddr *addr) {
 			ZEND_FALLTHROUGH;
 #endif
 		case AF_INET: {
+#ifndef WASM_WASI
 			zend_string *ret = zend_string_alloc(NI_MAXHOST, 0);
 			if (getnameinfo(addr, addrlen, ZSTR_VAL(ret), NI_MAXHOST, NULL, 0, NI_NUMERICHOST) == SUCCESS) {
 				/* Also demangle numeric host with %name suffix */
@@ -96,6 +97,9 @@ PHPAPI zend_string* php_inet_ntop(const struct sockaddr *addr) {
 			}
 			zend_string_efree(ret);
 			break;
+#else
+			return NULL;
+#endif // WASM_WASI
 		}
 	}
 
diff --git a/ext/standard/pageinfo.c b/ext/standard/pageinfo.c
index 06867fbda5..b789f99c55 100644
--- a/ext/standard/pageinfo.c
+++ b/ext/standard/pageinfo.c
@@ -61,8 +61,10 @@ PHPAPI void php_statpage(void)
 			BG(page_inode) = pstat->st_ino;
 			BG(page_mtime) = pstat->st_mtime;
 		} else { /* handler for situations where there is no source file, ex. php -r */
+#ifndef WASM_WASI
 			BG(page_uid) = getuid();
 			BG(page_gid) = getgid();
+#endif // WASM_WASI
 		}
 	}
 }
@@ -71,20 +73,29 @@ PHPAPI void php_statpage(void)
 /* {{{ php_getuid */
 zend_long php_getuid(void)
 {
+#ifndef WASM_WASI
 	php_statpage();
 	return (BG(page_uid));
+#else
+	return 0;
+#endif //WASM_WASI
 }
 /* }}} */
 
 zend_long php_getgid(void)
 {
+#ifndef WASM_WASI
 	php_statpage();
 	return (BG(page_gid));
+#else
+	return 0;
+#endif //WASM_WASI
 }
 
 /* {{{ Get PHP script owner's UID */
 PHP_FUNCTION(getmyuid)
 {
+#ifndef WASM_WASI
 	zend_long uid;
 
 	ZEND_PARSE_PARAMETERS_NONE();
@@ -95,6 +106,9 @@ PHP_FUNCTION(getmyuid)
 	} else {
 		RETURN_LONG(uid);
 	}
+#else
+	RETURN_LONG(0);
+#endif //WASM_WASI
 }
 /* }}} */
 
diff --git a/ext/standard/php_fopen_wrapper.c b/ext/standard/php_fopen_wrapper.c
index 4287045511..7fe983cb33 100644
--- a/ext/standard/php_fopen_wrapper.c
+++ b/ext/standard/php_fopen_wrapper.c
@@ -246,13 +246,17 @@ php_stream * php_stream_url_wrap_php(php_stream_wrapper *wrapper, const char *pa
 			static int cli_in = 0;
 			fd = STDIN_FILENO;
 			if (cli_in) {
-				fd = dup(fd);
+#ifndef WASM_WASI
+ 				fd = dup(fd);
+#endif // WASM_WASI
 			} else {
 				cli_in = 1;
 				file = stdin;
 			}
 		} else {
+#ifndef WASM_WASI
 			fd = dup(STDIN_FILENO);
+#endif // WASM_WASI
 		}
 #ifdef PHP_WIN32
 		pipe_requested = 1;
@@ -262,13 +266,17 @@ php_stream * php_stream_url_wrap_php(php_stream_wrapper *wrapper, const char *pa
 			static int cli_out = 0;
 			fd = STDOUT_FILENO;
 			if (cli_out++) {
-				fd = dup(fd);
+#ifndef WASM_WASI
+ 				fd = dup(fd);
+#endif // WASM_WASI
 			} else {
 				cli_out = 1;
 				file = stdout;
 			}
 		} else {
+#ifndef WASM_WASI
 			fd = dup(STDOUT_FILENO);
+#endif // WASM_WASI
 		}
 #ifdef PHP_WIN32
 		pipe_requested = 1;
@@ -278,13 +286,17 @@ php_stream * php_stream_url_wrap_php(php_stream_wrapper *wrapper, const char *pa
 			static int cli_err = 0;
 			fd = STDERR_FILENO;
 			if (cli_err++) {
+#ifndef WASM_WASI
 				fd = dup(fd);
+#endif // WASM_WASI
 			} else {
 				cli_err = 1;
 				file = stderr;
 			}
 		} else {
+#ifndef WASM_WASI
 			fd = dup(STDERR_FILENO);
+#endif // WASM_WASI
 		}
 #ifdef PHP_WIN32
 		pipe_requested = 1;
@@ -317,7 +329,7 @@ php_stream * php_stream_url_wrap_php(php_stream_wrapper *wrapper, const char *pa
 			return NULL;
 		}
 
-#if HAVE_UNISTD_H
+#if HAVE_UNISTD_H && !defined(WASM_WASI)
 		dtablesize = getdtablesize();
 #else
 		dtablesize = INT_MAX;
@@ -329,6 +341,7 @@ php_stream * php_stream_url_wrap_php(php_stream_wrapper *wrapper, const char *pa
 			return NULL;
 		}
 
+#ifndef WASM_WASI
 		fd = dup((int)fildes_ori);
 		if (fd == -1) {
 			php_stream_wrapper_log_error(wrapper, options,
@@ -336,6 +349,7 @@ php_stream * php_stream_url_wrap_php(php_stream_wrapper *wrapper, const char *pa
 				"[%d]: %s", fildes_ori, errno, strerror(errno));
 			return NULL;
 		}
+#endif // WASM_WASI
 	} else if (!strncasecmp(path, "filter/", 7)) {
 		/* Save time/memory when chain isn't specified */
 		if (strchr(mode, 'r') || strchr(mode, '+')) {
diff --git a/main/fastcgi.c b/main/fastcgi.c
index 9eb504bae7..66943b7c29 100644
--- a/main/fastcgi.c
+++ b/main/fastcgi.c
@@ -69,7 +69,9 @@ static int is_impersonate = 0;
 # include <netinet/in.h>
 # include <netinet/tcp.h>
 # include <arpa/inet.h>
+# ifndef WASM_WASI
 # include <netdb.h>
+# endif // WASM_WASI
 # include <signal.h>
 
 # if defined(HAVE_POLL_H) && defined(HAVE_POLL)
@@ -431,6 +433,7 @@ static void fcgi_signal_handler(int signo)
 
 static void fcgi_setup_signals(void)
 {
+#ifndef WASM_WASI
 	struct sigaction new_sa, old_sa;
 
 	sigemptyset(&new_sa.sa_mask);
@@ -442,6 +445,7 @@ static void fcgi_setup_signals(void)
 	if (old_sa.sa_handler == SIG_DFL) {
 		sigaction(SIGPIPE, &new_sa, NULL);
 	}
+#endif // WASM_WASI
 }
 #endif
 
@@ -526,6 +530,8 @@ int fcgi_init(void)
 		} else {
 			return is_fastcgi = 0;
 		}
+#elif defined(WASM_WASI)
+		return is_fastcgi = 0;
 #else
 		errno = 0;
 		if (getpeername(0, (struct sockaddr *)&sa, &len) != 0 && errno == ENOTCONN) {
@@ -675,6 +681,7 @@ int fcgi_listen(const char *path, int backlog)
 
 	/* Prepare socket address */
 	if (tcp) {
+#ifndef WASM_WASI
 		memset(&sa.sa_inet, 0, sizeof(sa.sa_inet));
 		sa.sa_inet.sin_family = AF_INET;
 		sa.sa_inet.sin_port = htons(port);
@@ -767,6 +774,7 @@ int fcgi_listen(const char *path, int backlog)
 	if (!tcp) {
 		chmod(path, 0777);
 	} else {
+#endif // WASM_WASI
 		char *ip = getenv("FCGI_WEB_SERVER_ADDRS");
 		char *cur, *end;
 		int n;
@@ -1099,7 +1107,9 @@ static int fcgi_read_request(fcgi_request *req)
 			int on = 1;
 # endif
 
+# ifndef WASM_WASI
 			setsockopt(req->fd, IPPROTO_TCP, TCP_NODELAY, (char*)&on, sizeof(on));
+# endif // WASM_WASI
 			req->nodelay = 1;
 		}
 #endif
@@ -1409,7 +1419,9 @@ int fcgi_accept_request(fcgi_request *req)
 					client_sa = sa;
 					if (req->fd >= 0 && !fcgi_is_allowed()) {
 						fcgi_log(FCGI_ERROR, "Connection disallowed: IP address '%s' has been dropped.", fcgi_get_last_client_ip());
+#ifndef WASM_WASI
 						closesocket(req->fd);
+#endif // WASM_WASI
 						req->fd = -1;
 						continue;
 					}
diff --git a/main/fopen_wrappers.c b/main/fopen_wrappers.c
index f6ce26e104..3d7c67b2de 100644
--- a/main/fopen_wrappers.c
+++ b/main/fopen_wrappers.c
@@ -52,7 +52,9 @@
 #include <winsock2.h>
 #else
 #include <netinet/in.h>
+#ifndef WASM_WASI
 #include <netdb.h>
+#endif // WASM_WASI
 #if HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
diff --git a/main/main.c b/main/main.c
index b536504be7..8314a9b2d3 100644
--- a/main/main.c
+++ b/main/main.c
@@ -1398,6 +1398,7 @@ static ZEND_COLD void php_error_cb(int orig_type, zend_string *error_filename, c
 /* {{{ php_get_current_user */
 PHPAPI char *php_get_current_user(void)
 {
+#ifndef WASM_WASI
 	zend_stat_t *pstat;
 
 	if (SG(request_info).current_user) {
@@ -1460,6 +1461,9 @@ PHPAPI char *php_get_current_user(void)
 		return SG(request_info).current_user;
 #endif
 	}
+#else
+	return "";
+#endif // WASM_WASI
 }
 /* }}} */
 
diff --git a/main/network.c b/main/network.c
index 1ad7e370cc..97d036784d 100644
--- a/main/network.c
+++ b/main/network.c
@@ -54,7 +54,9 @@
 
 #ifndef PHP_WIN32
 #include <netinet/in.h>
+#ifndef WASM_WASI
 #include <netdb.h>
+#endif // WASM_WASI
 #if HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
@@ -153,6 +155,7 @@ PHPAPI void php_network_freeaddresses(struct sockaddr **sal)
  */
 PHPAPI int php_network_getaddresses(const char *host, int socktype, struct sockaddr ***sal, zend_string **error_string)
 {
+#ifndef WASM_WASI
 	struct sockaddr **sap;
 	int n;
 #if HAVE_GETADDRINFO
@@ -275,6 +278,9 @@ PHPAPI int php_network_getaddresses(const char *host, int socktype, struct socka
 
 	*sap = NULL;
 	return n;
+#else
+	return 0;
+#endif // WASM_WASI
 }
 /* }}} */
 
@@ -310,6 +316,7 @@ PHPAPI int php_network_connect_socket(php_socket_t sockfd,
 		zend_string **error_string,
 		int *error_code)
 {
+#ifndef WASM_WASI
 	php_non_blocking_flags_t orig_flags;
 	int n;
 	int error = 0;
@@ -403,6 +410,9 @@ static inline void sub_times(struct timeval a, struct timeval b, struct timeval
 		result->tv_sec++;
 		result->tv_usec -= 1000000L;
 	}
+#else
+	return 0;
+#endif // WASM_WASI
 }
 /* }}} */
 
@@ -447,7 +457,11 @@ php_socket_t php_network_bind_socket_to_local_addr(const char *host, unsigned po
 		}
 
 		/* create a socket for this address */
+#ifndef WASM_WASI
 		sock = socket(sa->sa_family, socktype, 0);
+#else
+		sock = SOCK_ERR;
+#endif // WASM_WASI
 
 		if (sock == SOCK_ERR) {
 			continue;
@@ -456,31 +470,45 @@ php_socket_t php_network_bind_socket_to_local_addr(const char *host, unsigned po
 		/* attempt to bind */
 
 #ifdef SO_REUSEADDR
+#ifndef WASM_WASI
 		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char*)&sockoptval, sizeof(sockoptval));
+#endif // WASM_WASI
 #endif
 #ifdef IPV6_V6ONLY
 		if (sockopts & STREAM_SOCKOP_IPV6_V6ONLY) {
 			int ipv6_val = !!(sockopts & STREAM_SOCKOP_IPV6_V6ONLY_ENABLED);
+#ifndef WASM_WASI
 			setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&ipv6_val, sizeof(sockoptval));
+#endif // WASM_WASI
 		}
 #endif
 #ifdef SO_REUSEPORT
 		if (sockopts & STREAM_SOCKOP_SO_REUSEPORT) {
+#ifndef WASM_WASI
 			setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, (char*)&sockoptval, sizeof(sockoptval));
+#endif // WASM_WASI
 		}
 #endif
 #ifdef SO_BROADCAST
 		if (sockopts & STREAM_SOCKOP_SO_BROADCAST) {
+#ifndef WASM_WASI
 			setsockopt(sock, SOL_SOCKET, SO_BROADCAST, (char*)&sockoptval, sizeof(sockoptval));
+#endif // WASM_WASI
 		}
 #endif
 #ifdef TCP_NODELAY
 		if (sockopts & STREAM_SOCKOP_TCP_NODELAY) {
+#ifndef WASM_WASI
 			setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (char*)&sockoptval, sizeof(sockoptval));
+#endif // WASM_WASI
 		}
 #endif
 
+#ifndef WASM_WASI
 		n = bind(sock, sa, socklen);
+#else
+		n = SOCK_CONN_ERR;
+#endif // WASM_WASI
 
 		if (n != SOCK_CONN_ERR) {
 			goto bound;
@@ -613,6 +641,7 @@ PHPAPI void php_network_populate_name_from_sockaddr(
 		socklen_t *addrlen
 		)
 {
+#ifndef WASM_WASI
 	if (addr) {
 		*addr = emalloc(sl);
 		memcpy(*addr, sa, sl);
@@ -670,6 +699,7 @@ PHPAPI void php_network_populate_name_from_sockaddr(
 		}
 
 	}
+#endif // WASM_WASI
 }
 
 PHPAPI int php_network_get_peer_name(php_socket_t sock,
@@ -678,6 +708,7 @@ PHPAPI int php_network_get_peer_name(php_socket_t sock,
 		socklen_t *addrlen
 		)
 {
+#ifndef WASM_WASI
 	php_sockaddr_storage sa;
 	socklen_t sl = sizeof(sa);
 	memset(&sa, 0, sizeof(sa));
@@ -690,6 +721,9 @@ PHPAPI int php_network_get_peer_name(php_socket_t sock,
 		return 0;
 	}
 	return -1;
+#else
+	return 0;
+#endif // WASM_WASI
 }
 
 PHPAPI int php_network_get_sock_name(php_socket_t sock,
@@ -698,6 +732,7 @@ PHPAPI int php_network_get_sock_name(php_socket_t sock,
 		socklen_t *addrlen
 		)
 {
+#ifndef WASM_WASI
 	php_sockaddr_storage sa;
 	socklen_t sl = sizeof(sa);
 	memset(&sa, 0, sizeof(sa));
@@ -710,7 +745,9 @@ PHPAPI int php_network_get_sock_name(php_socket_t sock,
 		return 0;
 	}
 	return -1;
-
+#else
+	return 0;
+#endif // WASM_WASI
 }
 
 
@@ -756,7 +793,9 @@ PHPAPI php_socket_t php_network_accept_incoming(php_socket_t srvsock,
 					);
 			if (tcp_nodelay) {
 #ifdef TCP_NODELAY
+#ifndef WASM_WASI
 				setsockopt(clisock, IPPROTO_TCP, TCP_NODELAY, (char*)&tcp_nodelay, sizeof(tcp_nodelay));
+#endif // WASM_WASI
 #endif
 			}
 		} else {
@@ -873,7 +912,9 @@ php_socket_t php_network_connect_socket_to_host(const char *host, unsigned short
 					local_address_len = sizeof(struct sockaddr_in);
 					local_address.in4.sin_family = sa->sa_family;
 					local_address.in4.sin_port = htons(bindport);
+#ifndef WASM_WASI
 					memset(&(local_address.in4.sin_zero), 0, sizeof(local_address.in4.sin_zero));
+#endif // WASM_WASI
 				}
 			}
 #if HAVE_IPV6 && HAVE_INET_PTON
@@ -901,7 +942,9 @@ php_socket_t php_network_connect_socket_to_host(const char *host, unsigned short
 		{
 			int val = 1;
 			if (sockopts & STREAM_SOCKOP_SO_BROADCAST) {
+#ifndef WASM_WASI
 				setsockopt(sock, SOL_SOCKET, SO_BROADCAST, (char*)&val, sizeof(val));
+#endif // WASM_WASI
 			}
 		}
 #endif
@@ -910,7 +953,9 @@ php_socket_t php_network_connect_socket_to_host(const char *host, unsigned short
 		{
 			int val = 1;
 			if (sockopts & STREAM_SOCKOP_TCP_NODELAY) {
+#ifndef WASM_WASI
 				setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (char*)&val, sizeof(val));
+#endif // WASM_WASI
 			}
 		}
 #endif
@@ -1316,6 +1361,7 @@ struct hostent * gethostname_re (const char *host,struct hostent *hostbuf,char *
 #endif
 
 PHPAPI struct hostent*	php_network_gethostbyname(const char *name) {
+#ifndef WASM_WASI
 #if !defined(HAVE_GETHOSTBYNAME_R)
 	return gethostbyname(name);
 #else
@@ -1330,4 +1376,7 @@ PHPAPI struct hostent*	php_network_gethostbyname(const char *name) {
 
 	return gethostname_re(name, &FG(tmp_host_info), &FG(tmp_host_buf), &FG(tmp_host_buf_len));
 #endif
+#else
+	return NULL;
+#endif // WASM_WASI
 }
diff --git a/main/php_open_temporary_file.c b/main/php_open_temporary_file.c
index dcea783584..57bd337835 100644
--- a/main/php_open_temporary_file.c
+++ b/main/php_open_temporary_file.c
@@ -30,7 +30,9 @@
 #include <sys/param.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
+#ifndef WASM_WASI
 #include <netdb.h>
+#endif
 #if HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
@@ -97,7 +99,7 @@ static int php_do_open_temporary_file(const char *path, const char *pfx, zend_st
 	char cwd[MAXPATHLEN];
 	cwd_state new_state;
 	int fd = -1;
-#ifndef HAVE_MKSTEMP
+#if !defined(HAVE_MKSTEMP) || defined(WASM_WASI)
 	int open_flags = O_CREAT | O_TRUNC | O_RDWR
 #ifdef PHP_WIN32
 		| _O_BINARY
@@ -177,6 +179,8 @@ static int php_do_open_temporary_file(const char *path, const char *pfx, zend_st
 	free(pfxw);
 #elif defined(HAVE_MKSTEMP)
 	fd = mkstemp(opened_path);
+#elif defined(WASM_WASI)
+	fd = VCWD_OPEN(opened_path, open_flags);
 #else
 	if (mktemp(opened_path)) {
 		fd = VCWD_OPEN(opened_path, open_flags);
diff --git a/main/php_syslog.c b/main/php_syslog.c
index fa71a86313..68c7aac707 100644
--- a/main/php_syslog.c
+++ b/main/php_syslog.c
@@ -105,6 +105,7 @@ PHPAPI void php_syslog(int priority, const char *format, ...) /* {{{ */
 #else
 PHPAPI void php_syslog(int priority, const char *format, ...) /* {{{ */
 {
+#ifndef WASM_WASI
 	zend_string *fbuf = NULL;
 	va_list args;
 
@@ -124,6 +125,7 @@ PHPAPI void php_syslog(int priority, const char *format, ...) /* {{{ */
 	php_syslog_str(priority, fbuf);
 
 	zend_string_release(fbuf);
+#endif // WASM_WASI
 }
 /* }}} */
 #endif
diff --git a/main/streams/plain_wrapper.c b/main/streams/plain_wrapper.c
index f8c3d89aef..6695a2f318 100644
--- a/main/streams/plain_wrapper.c
+++ b/main/streams/plain_wrapper.c
@@ -490,7 +490,9 @@ static int php_stdiop_close(php_stream *stream, int close_handle)
 		if (data->file) {
 			if (data->is_process_pipe) {
 				errno = 0;
+#ifndef WASM_WASI
 				ret = pclose(data->file);
+#endif
 
 #ifdef HAVE_SYS_WAIT_H
 				if (WIFEXITED(ret)) {
@@ -1292,13 +1294,18 @@ static int php_plain_files_rename(php_stream_wrapper *wrapper, const char *url_f
 			zend_stat_t sb;
 # if !defined(ZTS) && !defined(TSRM_WIN32)
 			/* not sure what to do in ZTS case, umask is not thread-safe */
+# ifndef WASM_WASI
 			int oldmask = umask(077);
+# else
+			int oldmask = 077;
+# endif // WASM_WASI
 # endif
 			int success = 0;
 			if (php_copy_file(url_from, url_to) == SUCCESS) {
 				if (VCWD_STAT(url_from, &sb) == 0) {
 					success = 1;
-#  ifndef TSRM_WIN32
+#  ifndef WASM_WASI
+#   ifndef TSRM_WIN32
 					/*
 					 * Try to set user and permission info on the target.
 					 * If we're not root, then some of these may fail.
@@ -1321,7 +1328,8 @@ static int php_plain_files_rename(php_stream_wrapper *wrapper, const char *url_f
 							}
 						}
 					}
-#  endif
+#   endif
+#  endif // WASM_WASI
 					if (success) {
 						VCWD_UNLINK(url_from);
 					}
@@ -1332,7 +1340,9 @@ static int php_plain_files_rename(php_stream_wrapper *wrapper, const char *url_f
 				php_error_docref2(NULL, url_from, url_to, E_WARNING, "%s", strerror(errno));
 			}
 #  if !defined(ZTS) && !defined(TSRM_WIN32)
+#  ifndef WASM_WASI
 			umask(oldmask);
+#  endif // WASM_WASI
 #  endif
 			return success;
 		}
@@ -1523,7 +1533,11 @@ static int php_plain_files_metadata(php_stream_wrapper *wrapper, const char *url
 			} else {
 				uid = (uid_t)*(long *)value;
 			}
+#ifndef WASM_WASI
 			ret = VCWD_CHOWN(url, uid, -1);
+#else
+			ret = 0;
+#endif // WASM_WASI
 			break;
 		case PHP_STREAM_META_GROUP:
 		case PHP_STREAM_META_GROUP_NAME:
@@ -1535,12 +1549,20 @@ static int php_plain_files_metadata(php_stream_wrapper *wrapper, const char *url
 			} else {
 				gid = (gid_t)*(long *)value;
 			}
-			ret = VCWD_CHOWN(url, -1, gid);
+#ifndef WASM_WASI
+			ret = VCWD_CHvOWN(url, -1, gid);
+#else
+			ret = 0;
+#endif // WASM_WASI
 			break;
 #endif
 		case PHP_STREAM_META_ACCESS:
 			mode = (mode_t)*(zend_long *)value;
+#ifndef WASM_WASI
 			ret = VCWD_CHMOD(url, mode);
+#else
+			ret = 0;
+#endif // WASM_WASI
 			break;
 		default:
 			zend_value_error("Unknown option %d for stream_metadata", option);
diff --git a/main/streams/xp_socket.c b/main/streams/xp_socket.c
index b17eccf2ee..833a19ddda 100644
--- a/main/streams/xp_socket.c
+++ b/main/streams/xp_socket.c
@@ -219,7 +219,9 @@ static int php_sockop_close(php_stream *stream, int close_handle)
 				n = php_pollfd_for_ms(sock->socket, POLLOUT, 500);
 			} while (n == -1 && php_socket_errno() == EINTR);
 #endif
+#ifndef WASM_WASI
 			closesocket(sock->socket);
+#endif // WASM_WASI
 			sock->socket = SOCK_ERR;
 		}
 
@@ -256,8 +258,11 @@ static inline int sock_sendto(php_netstream_data_t *sock, const char *buf, size_
 {
 	int ret;
 	if (addr) {
+#ifndef WASM_WASI
 		ret = sendto(sock->socket, buf, XP_SOCK_BUF_SIZE(buflen), flags, addr, XP_SOCK_BUF_SIZE(addrlen));
-
+#else
+		ret = 0;
+#endif // WASM_WASI
 		return (ret == SOCK_CONN_ERR) ? -1 : ret;
 	}
 #ifdef PHP_WIN32
@@ -278,7 +283,11 @@ static inline int sock_recvfrom(php_netstream_data_t *sock, char *buf, size_t bu
 	if (want_addr) {
 		php_sockaddr_storage sa;
 		socklen_t sl = sizeof(sa);
+#ifndef WASM_WASI
 		ret = recvfrom(sock->socket, buf, XP_SOCK_BUF_SIZE(buflen), flags, (struct sockaddr*)&sa, &sl);
+#else
+		ret = 0;
+#endif // WASM_WASI
 		ret = (ret == SOCK_CONN_ERR) ? -1 : ret;
 #ifdef PHP_WIN32
 		/* POSIX discards excess bytes without signalling failure; emulate this on Windows */
@@ -337,6 +346,7 @@ static int php_sockop_set_option(php_stream *stream, int option, int value, void
 
 				if (sock->socket == -1) {
 					alive = 0;
+#ifndef WASM_WASI
 				} else if (php_pollfd_for(sock->socket, PHP_POLLREADABLE|POLLPRI, &tv) > 0) {
 #ifdef PHP_WIN32
 					int ret;
@@ -351,6 +361,7 @@ static int php_sockop_set_option(php_stream *stream, int option, int value, void
 						(0 > ret && err != EWOULDBLOCK && err != EAGAIN && err != EMSGSIZE)) { /* there was an unrecoverable error */
 						alive = 0;
 					}
+#endif // WASM_WASI
 				}
 				return alive ? PHP_STREAM_OPTION_RETURN_OK : PHP_STREAM_OPTION_RETURN_ERR;
 			}
@@ -379,7 +390,11 @@ static int php_sockop_set_option(php_stream *stream, int option, int value, void
 
 			switch (xparam->op) {
 				case STREAM_XPORT_OP_LISTEN:
+#ifndef WASM_WASI
 					xparam->outputs.returncode = (listen(sock->socket, xparam->inputs.backlog) == 0) ?  0: -1;
+#else
+					xparam->outputs.returncode = 0;
+#endif // WASM_WASI
 					return PHP_STREAM_OPTION_RETURN_OK;
 
 				case STREAM_XPORT_OP_GET_NAME:
@@ -401,7 +416,9 @@ static int php_sockop_set_option(php_stream *stream, int option, int value, void
 				case STREAM_XPORT_OP_SEND:
 					flags = 0;
 					if ((xparam->inputs.flags & STREAM_OOB) == STREAM_OOB) {
+#ifndef WASM_WASI
 						flags |= MSG_OOB;
+#endif // WASM_WASI
 					}
 					xparam->outputs.returncode = sock_sendto(sock,
 							xparam->inputs.buf, xparam->inputs.buflen,
@@ -419,10 +436,14 @@ static int php_sockop_set_option(php_stream *stream, int option, int value, void
 				case STREAM_XPORT_OP_RECV:
 					flags = 0;
 					if ((xparam->inputs.flags & STREAM_OOB) == STREAM_OOB) {
+#ifndef WASM_WASI
 						flags |= MSG_OOB;
+#endif // WASM_WASI
 					}
 					if ((xparam->inputs.flags & STREAM_PEEK) == STREAM_PEEK) {
+#ifndef WASM_WASI
 						flags |= MSG_PEEK;
+#endif // WASM_WASI
 					}
 					xparam->outputs.returncode = sock_recvfrom(sock,
 							xparam->inputs.buf, xparam->inputs.buflen,
@@ -556,6 +577,7 @@ static inline int parse_unix_address(php_stream_xport_param *xparam, struct sock
 	memset(unix_addr, 0, sizeof(*unix_addr));
 	unix_addr->sun_family = AF_UNIX;
 
+#ifndef WASM_WASI
 	/* we need to be binary safe on systems that support an abstract
 	 * namespace */
 	if (xparam->inputs.namelen >= sizeof(unix_addr->sun_path)) {
@@ -571,6 +593,7 @@ static inline int parse_unix_address(php_stream_xport_param *xparam, struct sock
 	}
 
 	memcpy(unix_addr->sun_path, xparam->inputs.name, xparam->inputs.namelen);
+#endif // WASM_WASI
 
 	return 1;
 }
@@ -632,7 +655,9 @@ static inline int php_tcp_sockop_bind(php_stream *stream, php_netstream_data_t *
 	if (stream->ops == &php_stream_unix_socket_ops || stream->ops == &php_stream_unixdg_socket_ops) {
 		struct sockaddr_un unix_addr;
 
+#ifndef WASM_WASI
 		sock->socket = socket(PF_UNIX, stream->ops == &php_stream_unix_socket_ops ? SOCK_STREAM : SOCK_DGRAM, 0);
+#endif // WASM_WASI
 
 		if (sock->socket == SOCK_ERR) {
 			if (xparam->want_errortext) {
@@ -645,8 +670,12 @@ static inline int php_tcp_sockop_bind(php_stream *stream, php_netstream_data_t *
 
 		parse_unix_address(xparam, &unix_addr);
 
+#ifndef WASM_WASI
 		return bind(sock->socket, (const struct sockaddr *)&unix_addr,
 			(socklen_t) XtOffsetOf(struct sockaddr_un, sun_path) + xparam->inputs.namelen);
+#else
+		return 0;
+#endif // WASM_WASI
 	}
 #endif
 
@@ -713,7 +742,9 @@ static inline int php_tcp_sockop_connect(php_stream *stream, php_netstream_data_
 	if (stream->ops == &php_stream_unix_socket_ops || stream->ops == &php_stream_unixdg_socket_ops) {
 		struct sockaddr_un unix_addr;
 
+#ifndef WASM_WASI
 		sock->socket = socket(PF_UNIX, stream->ops == &php_stream_unix_socket_ops ? SOCK_STREAM : SOCK_DGRAM, 0);
+#endif // WASM_WASI
 
 		if (sock->socket == SOCK_ERR) {
 			if (xparam->want_errortext) {
@@ -725,7 +756,11 @@ static inline int php_tcp_sockop_connect(php_stream *stream, php_netstream_data_
 		parse_unix_address(xparam, &unix_addr);
 
 		ret = php_network_connect_socket(sock->socket,
+#ifndef WASM_WASI
 				(const struct sockaddr *)&unix_addr, (socklen_t) XtOffsetOf(struct sockaddr_un, sun_path) + xparam->inputs.namelen,
+#else
+				(const struct sockaddr *)&unix_addr, xparam->inputs.namelen,
+#endif // WASM_WASI
 				xparam->op == STREAM_XPORT_OP_CONNECT_ASYNC, xparam->inputs.timeout,
 				xparam->want_errortext ? &xparam->outputs.error_text : NULL,
 				&err);
diff --git a/sapi/cgi/cgi_main.c b/sapi/cgi/cgi_main.c
index 499a7932be..69e6de5364 100644
--- a/sapi/cgi/cgi_main.c
+++ b/sapi/cgi/cgi_main.c
@@ -43,7 +43,9 @@
 # include <unistd.h>
 #endif
 
+#ifndef WASM_WASI
 #include <signal.h>
+#endif // WASM_WASI
 
 #include <locale.h>
 
@@ -94,10 +96,12 @@ int __riscosify_control = __RISCOSIFY_STRICT_UNIX_SPECS;
 # include "valgrind/callgrind.h"
 #endif
 
+#ifndef WASM_WASI
 #ifndef PHP_WIN32
 /* XXX this will need to change later when threaded fastcgi is implemented.  shane */
 struct sigaction act, old_term, old_quit, old_int;
 #endif
+#endif // WASM_WASI
 
 static void (*php_php_import_environment_variables)(zval *array_ptr);
 
@@ -1458,6 +1462,7 @@ static void init_request_info(fcgi_request *request)
  */
 void fastcgi_cleanup(int signal)
 {
+#ifndef WASM_WASI
 #ifdef DEBUG_FASTCGI
 	fprintf(stderr, "FastCGI shutdown, pid %d\n", getpid());
 #endif
@@ -1472,6 +1477,9 @@ void fastcgi_cleanup(int signal)
 	} else {
 		exit(0);
 	}
+#else
+	exit(0);
+#endif // WASM_WASI
 }
 #else
 BOOL WINAPI fastcgi_cleanup(DWORD sig)
@@ -1767,7 +1775,9 @@ int main(int argc, char *argv[])
 # endif
 #endif
 
+#ifndef WASM_WASI
 	zend_signal_startup();
+#endif // WASM_WASI
 
 #ifdef ZTS
 	ts_allocate_id(&php_cgi_globals_id, sizeof(php_cgi_globals_struct), (ts_allocate_ctor) php_cgi_globals_ctor, NULL);
@@ -1897,6 +1907,7 @@ int main(int argc, char *argv[])
 		return FAILURE;
 	}
 
+#ifndef WASM_WASI
 	/* check force_cgi after startup, so we have proper output */
 	if (cgi && CGIG(force_redirect)) {
 		/* Apache will generate REDIRECT_STATUS,
@@ -1937,6 +1948,7 @@ consult the installation file that came with this distribution, or visit \n\
 			return FAILURE;
 		}
 	}
+#endif // WASM_WASI
 
 #ifndef HAVE_ATTRIBUTE_WEAK
 	fcgi_set_logger(fcgi_log);
@@ -2013,12 +2025,17 @@ consult the installation file that came with this distribution, or visit \n\
 			pid_t pid;
 
 			/* Create a process group for us & children */
+#ifndef WASM_WASI
 			setsid();
 			pgroup = getpgrp();
+#else
+			pgroup = 0;
+#endif // WASM_WASI
 #ifdef DEBUG_FASTCGI
 			fprintf(stderr, "Process group %d\n", pgroup);
 #endif
 
+#ifndef WASM_WASI
 			/* Set up handler to kill children upon exit */
 			act.sa_flags = 0;
 			act.sa_handler = fastcgi_cleanup;
@@ -2029,6 +2046,7 @@ consult the installation file that came with this distribution, or visit \n\
 				perror("Can't set signals");
 				exit(1);
 			}
+#endif // WASM_WASI
 
 			if (fcgi_in_shutdown()) {
 				goto parent_out;
@@ -2039,7 +2057,11 @@ consult the installation file that came with this distribution, or visit \n\
 #ifdef DEBUG_FASTCGI
 					fprintf(stderr, "Forking, %d running\n", running);
 #endif
+#ifndef WASM_WASI
 					pid = fork();
+#else
+					pid = 1;
+#endif // WASM_WASI
 					switch (pid) {
 					case 0:
 						/* One of the children.
@@ -2048,11 +2070,13 @@ consult the installation file that came with this distribution, or visit \n\
 						 */
 						parent = 0;
 
+#ifndef WASM_WASI
 						/* don't catch our signals */
 						sigaction(SIGTERM, &old_term, 0);
 						sigaction(SIGQUIT, &old_quit, 0);
 						sigaction(SIGINT,  &old_int,  0);
 						zend_signal_init();
+#endif // WASM_WASI
 						break;
 					case -1:
 						perror("php (pre-forking)");
@@ -2071,12 +2095,14 @@ consult the installation file that came with this distribution, or visit \n\
 #endif
 					parent_waiting = 1;
 					while (1) {
+#ifndef WASM_WASI
 						if (wait(&status) >= 0) {
 							running--;
 							break;
 						} else if (exit_signal) {
 							break;
 						}
+#endif // WASM_WASI
 					}
 					if (exit_signal) {
 #if 0
diff --git a/sapi/fpm/fpm/fpm_unix.c b/sapi/fpm/fpm/fpm_unix.c
index ed5b66294f..adf3adb75f 100644
--- a/sapi/fpm/fpm/fpm_unix.c
+++ b/sapi/fpm/fpm/fpm_unix.c
@@ -9,7 +9,9 @@
 #include <unistd.h>
 #include <sys/types.h>
 #include <pwd.h>
+#ifdef HAVE_GRP_H
 #include <grp.h>
+#endif
 
 #ifdef HAVE_PRCTL
 #include <sys/prctl.h>
diff --git a/sapi/litespeed/lsapilib.c b/sapi/litespeed/lsapilib.c
index 2208bbd47b..26d0d307b1 100644
--- a/sapi/litespeed/lsapilib.c
+++ b/sapi/litespeed/lsapilib.c
@@ -65,7 +65,9 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <sys/time.h>
 #include <sys/uio.h>
 #include <sys/wait.h>
+#ifdef HAVE_GRP_H
 #include <grp.h>
+#endif
 #include <pwd.h>
 #include <time.h>
 #include <unistd.h>
-- 
2.38.1

